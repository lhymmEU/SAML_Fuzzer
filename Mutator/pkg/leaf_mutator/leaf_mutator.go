package leaf_mutator

import (
	"fmt"
	"math/rand"
	"os"
	"strings"
	"time"
	"xmlMutator/pkg/helpers"
	"xmlMutator/pkg/parser"
)



// This function would:
// 1. Read-in the 4 files generated by the parser.
// 2. Generate 3 string slices from the file "attributes.txt", "content_val.txt", "tag_name.txt".
// 3. Go through the file "attributes.txt" and extract names and values into two different slices.
// 4. Go through the file "terminals.txt" and apply the mutation strategy.
// 5. Write the resulting string to file.


func LeafMutator(filePath string, valueLocking bool) {

	// Generate 3 string slices
	attrFile, err := os.Open(parser.FileGenPath + "attributes.txt")
	if err != nil {
		fmt.Printf("LeafMutator() - Read file attributes.txt failed: %s", err)
		return
	}
	defer attrFile.Close()
	attrSlice := helpers.ReadFileToSlice(attrFile)

	// Split into two sub-slices
	attrName := make([]string, len(attrSlice)-1)
	attrVal := make([]string, len(attrSlice)-1)
	for i, v := range attrSlice[1:] {
		tmp := strings.Split(v, "=")
		attrName[i] = tmp[0]
		attrVal[i] = tmp[1]
	}

	contentFile, err := os.Open(parser.FileGenPath + "content_val.txt")
	if err != nil {
		fmt.Printf("LeafMutator() - Read file content_val.txt failed: %s", err)
		return
	}
	defer attrFile.Close()
	contentSlice := helpers.ReadFileToSlice(contentFile)

	tagFile, err := os.Open(parser.FileGenPath + "tag_name.txt")
	if err != nil {
		fmt.Printf("LeafMutator() - Read file tag_name.txt failed: %s", err)
		return
	}
	defer attrFile.Close()
	tagSlice := helpers.ReadFileToSlice(tagFile)

	// Go through the terminals.txt
	terminalFile, err := os.Open(parser.FileGenPath + "terminals.txt")
	if err != nil {
		fmt.Printf("LeafMutator() - Read file terminals.txt failed: %s", err)
		return
	}
	defer terminalFile.Close()
	terminalsSlice := helpers.ReadFileToSlice(terminalFile)

	mutateMask, elePick := LeafMutationStrategy(len(terminalsSlice))
	for i, v := range terminalsSlice {
		if v == "" {continue}
		switch mutateMask[i] {
		case 0:
			break
		case 1:
			// In case of a deletion, replace the original string with an empty one.
			// TODO: for now, deletion seems like not working good enough
			//terminalsSlice[i] = ""
			break
		case 2:
			// In case of a replacement, replace the string with the same type string.
			if Find(v, attrName) && !valueLocking {
				DoReplace(i, elePick[i] % len(attrName), terminalsSlice, attrName)
			}
			if Find(v, attrVal) && !valueLocking {
				DoReplace(i, elePick[i] % len(attrVal), terminalsSlice, attrVal)
			}
			if Find(v, contentSlice) {
				DoReplace(i, elePick[i] % len(contentSlice), terminalsSlice, contentSlice)
			}
			if Find(v, tagSlice) {
				DoReplace(i, elePick[i] % len(tagSlice), terminalsSlice, tagSlice)
			}
		default:
			break
		}
	}

	xmlString := helpers.BuildXMLString(terminalsSlice)
	for _, v := range attrSlice[1:] {
		xmlString = helpers.XMLStringRefactor("", xmlString, v)
	}

	// Write the resulting xml string to folder
	helpers.WriteStringToFile(xmlString, filePath)

}

func Find(v string, slice []string) bool {
	for _, value := range slice {
		if v == value {
			return true
		}
	}

	return false
}

// Input: an index indicates the element to replace; an index indicates the replacement element; the terminal slice; the slice contains the replacements.

func DoReplace(i int, j int, t []string, r []string) {
	t[i] = r[j]
}

// TODO: add the evolvable probability profile
/*
	This function will randomly choose: (with an evolvable probability profile)
		1. Take in a number l that indicate how many terminals we need to deal with.
		2. Return a map of length l:
			The key indicates:
			1) 0 for no mutation, 1 for delete, 2 for replace.
			The value indicates:
			1) -1 for no mutation and delete.
			2) a random value with range [0, l)
			2) the caller should handle the case when the returned random number is out of index. (use a modulo)
 */

func LeafMutationStrategy(l int) ([]int, []int){
	mutateMask := []int{}
	elePick := []int{}

	rand.Seed(time.Now().UnixNano())

	for i := 0; i < l; i++ {
		mNum := rand.Intn(3)
		mutateMask = append(mutateMask, mNum)
		eNum := rand.Intn(l)
		elePick = append(elePick, eNum)
	}

	return mutateMask, elePick
}
